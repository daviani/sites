Beyond the basic `useState` and `useEffect` hooks, React offers advanced hooks that help optimize **performance** and handle complex use cases.

## useCallback - Memoize Functions

`useCallback` memoizes a function to prevent its recreation on every render. This is particularly useful when passing callbacks to optimized child components.

### The Problem

Without `useCallback`, each render creates a new function reference:

```tsx
function Parent() {
  const [count, setCount] = useState(0);

  // ❌ New function on every render
  const handleClick = () => {
    console.log('Clicked!');
  };

  return <Child onClick={handleClick} />;
}
```

### The Solution

```tsx
function Parent() {
  const [count, setCount] = useState(0);

  // ✅ Same reference across renders
  const handleClick = useCallback(() => {
    console.log('Clicked!');
  }, []);

  return <Child onClick={handleClick} />;
}
```

## useMemo - Memoize Expensive Calculations

`useMemo` memoizes the result of an expensive calculation:

```tsx
function ProductList({ products, filter }: Props) {
  // Memoized calculation - only runs when products or filter changes
  const filteredProducts = useMemo(() => {
    return products.filter((product) =>
      product.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [products, filter]);

  return (
    <ul>
      {filteredProducts.map((product) => (
        <li key={product.id}>{product.name}</li>
      ))}
    </ul>
  );
}
```

> **Warning**: Don't use `useMemo` everywhere! Reserve it for truly expensive calculations.

## useRef - Persist Values

`useRef` has two main uses:

1. **Access DOM elements**
2. **Persist values across renders** without triggering re-renders

### DOM Access

```tsx
function TextInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  const focusInput = () => {
    inputRef.current?.focus();
  };

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus</button>
    </>
  );
}
```

### Persistent Value

```tsx
function Timer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    intervalRef.current = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  return <p>Count: {count}</p>;
}
```

## useReducer - Complex State

For complex states with multiple sub-values, `useReducer` is often more suitable than `useState`:

```tsx
type State = {
  loading: boolean;
  error: string | null;
  data: User | null;
};

type Action =
  | { type: 'FETCH_START' }
  | { type: 'FETCH_SUCCESS'; payload: User }
  | { type: 'FETCH_ERROR'; payload: string };

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return { loading: false, error: null, data: action.payload };
    case 'FETCH_ERROR':
      return { loading: false, error: action.payload, data: null };
    default:
      return state;
  }
}

function UserProfile({ userId }: { userId: string }) {
  const [state, dispatch] = useReducer(reducer, {
    loading: false,
    error: null,
    data: null,
  });

  // Usage with dispatch...
}
```

## When to Use What?

Here's a summary:

| Hook | Usage |
|------|-------|
| `useCallback` | Functions passed as props |
| `useMemo` | Expensive calculations |
| `useRef` | DOM or persistent values |
| `useReducer` | Complex state |

## Best Practices

To summarize best practices:

- **Measure before optimizing** - Use React DevTools Profiler
- **Avoid premature optimization** - Readability comes first
- **Correct dependencies** - Include all used values
- **Custom hooks** - Extract reusable logic

## Conclusion

React's advanced hooks are powerful tools for *optimizing* your applications. Use them wisely by focusing on cases where they provide **real added value**.